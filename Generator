local Bot = Instance.new("ModuleScript")
Bot.Name = "Bot"
Bot.Source = "local Funcs = {}\n\n_G.AI_Enabled = true\n\nfor i,v in pairs(script:GetChildren()) do \n	local Data = require(v)\n	if typeof(Data) == \'table\' then \n		for ii,vv in pairs(Data) do \n			Funcs[ii] = vv\n		end\n	else\n		Funcs[v.Name]= Data\n	end\nend\n\n\n--strategy that you jump (when you can run away in a straight line) while opponent's lunge is down\n\n--strategy that you walk around the opponent while running away\n\n--don't go after the left side if the opponent is hugging the wall\n--don't spam hit while not in range (gives opportunity for enemy to attack while lunge is down)\n--make it go closer when the opponent's attack is on cooldown\n--realize that once it's being attacked, if the opponent is plays optimally it can't dodge so try maneuvers while attacking\n--make it not attempt to back off when it's already being hit\n--back off when lunging Almost over and down\n\n--detecting when enemy is about to lunge doesn't work\n\n\n\nlocal GetXDist = function(Pos1, Pos2)\n	return math.sqrt((Pos1.X - Pos2.X)^2+(Pos1.Z - Pos2.Z)^2)\nend\n\nlocal FairLookAt = function(Pos1, Pos2)\n	return CFrame.lookAt(Pos1, (Pos2 - Vector3.new(0,Pos2.Y - Pos1.Y,0))) * CFrame.Angles(0,math.rad(17.5),0)\nend\n\n\nGrips = {\n	Up = CFrame.new(0, 0, -1.70000005, 0, 0, 1, 1, 0, 0, 0, 1, 0),\n	Out = CFrame.new(0, 0, -1.70000005, 0, 1, 0, 1, -0, 0, 0, 0, -1)\n}\n\n--local LungingGui = game.Players.LocalPlayer.PlayerGui:WaitForChild(\'Game\').Lunging\n\n\nreturn function(Model, isPlayer, teamCheck, targetTeam)\n	local Humanoid = Model.Humanoid\n	local PrimaryPart = Model.PrimaryPart\n	local Tool = Model:FindFirstChildOfClass(\'Tool\')\n	if not Tool then \n		repeat Tool = Model:FindFirstChildOfClass(\'Tool\'); wait() until Tool\n	end\n	local Tick = 0\n	local LastAttack = 0\n	local LastOpponentAttack = 0\n	local EnemyExtended = false\n	while Model.PrimaryPart and Humanoid and Humanoid.Health > 0 and Model.Parent == workspace and _G.AI_Enabled do  \n		Tick += game:GetService(\'RunService\').RenderStepped:Wait()\n		local ClosestEnemy = Funcs.GetClosestEnemy(Model, teamCheck)\n		\n		if ClosestEnemy then \n			local ClosestPart = Funcs.GetClosestPart(Tool.Handle.Position, ClosestEnemy)\n			local EnemyTool = ClosestEnemy:FindFirstChildOfClass(\'Tool\')\n			\n			local LungeCooldown = false\n			if EnemyTool then \n				if EnemyTool.Grip == Grips.Out then\n					if EnemyExtended == false then \n						LastOpponentAttack = Tick\n					end\n					EnemyExtended = true\n				end\n			end\n			if Tool.Grip ~= Grips.Out then\n				LungeCooldown = true\n			end\n			\n			local HigherHp = Model.Humanoid.Health > ClosestEnemy.Humanoid.Health\n			local LowerHp = Model.Humanoid.Health < ClosestEnemy.Humanoid.Health\n			local XDist = GetXDist(Model.PrimaryPart.Position, ClosestEnemy.PrimaryPart.Position)\n			\n			local Distance = Funcs.GetDistance(Model, ClosestEnemy)\n			local HeightDifference = math.abs(ClosestEnemy.PrimaryPart.Position.Y - Model.PrimaryPart.Position.Y)\n			\n			local SameHeight = HeightDifference < 3\n			\n			local ClosestPos = ClosestEnemy.PrimaryPart.Position\n			--LungingGui.BackgroundColor3 = EnemyExtended and Color3.new(0.0470588, 1, 0) or Color3.new(1, 1, 1)\n		\n			if EnemyExtended and LungeCooldown and SameHeight and Distance > 6 and EnemyTool then \n				--Tool.Grip = Grips.Up\n				\n				Model:SetPrimaryPartCFrame(FairLookAt(PrimaryPart.Position, EnemyTool.Handle.Position+ ClosestEnemy.PrimaryPart.CFrame.LookVector*EnemyTool.Handle.Size.Y*2.2))\n			else \n				if Tool.Parent ~= Model then\n					Humanoid:EquipTool(Tool)\n				end\n				Tool.Parent = Model\n				\n				\n				Model:SetPrimaryPartCFrame(CFrame.lookAt(PrimaryPart.Position, (ClosestPart.Position - Vector3.new(0,ClosestPart.Position.Y - PrimaryPart.Position.Y,0))) * CFrame.Angles(0,math.rad(17.5),0))\n				local Angle = 0\n				local LastAngle = Angle\n				--points sword towards closest position on part\n				for i = 1, 10 do\n					Angle = Angle + Funcs.FindBestAngle(Model, ClosestEnemy, EnemyTool)\n					if LastAngle == Angle then \n						-- the wiggle to trigger touched\n							if HigherHp then\n								Angle += math.random(-10,10) --10\n							else \n								Angle += math.random(-2,2) -- -2, 2\n							end\n							Model:SetPrimaryPartCFrame(CFrame.lookAt(PrimaryPart.Position, (ClosestPart.Position - Vector3.new(0,ClosestPart.Position.Y - PrimaryPart.Position.Y,0))) * CFrame.Angles(0,math.rad(17.5 + Angle),0))\n						break\n					end\n					LastAngle = Angle\n					Model:SetPrimaryPartCFrame(CFrame.lookAt(PrimaryPart.Position, (ClosestPart.Position - Vector3.new(0,ClosestPart.Position.Y - PrimaryPart.Position.Y,0))) * CFrame.Angles(0,math.rad(17.5 + Angle),0))\n				end\n			end \n			\n			local EnemyToModelVector = (Model.PrimaryPart.Position - ClosestEnemy.PrimaryPart.Position).Unit\n			local MoveDirection = ClosestEnemy.Humanoid.MoveDirection\n			local EnemyIsMovingTowardsModel = (EnemyToModelVector - MoveDirection).Magnitude < 1\n			--goes really aggresive when enemy is on cooldown\n			local IdealDistance = EnemyExtended and 7 or 6.5 --8 7\n			--backs off\n			IdealDistance += EnemyIsMovingTowardsModel and 1.5 or 0 --2 0\n			\n			\n			--detects when last lunged\n			--and (Tick - LastAttack > 0.2) -- putting this here for science\n			if Tool.Enabled and Tool.Grip == Grips.Up then\n				\n				LastAttack = Tick\n			end\n			\n			--pushes when enemy is about to run out of lunge (hopefully)\n			if EnemyTool and not EnemyTool.Enabled and (Tick - LastOpponentAttack > 0.1) and not (Tick - LastOpponentAttack < 0.2) and  (Tick - LastAttack > 0.05) then \n				IdealDistance -= 1.5 -- 2\n			end\n			\n			--LungingGui.BackgroundColor3 = Color3.new(1, 1, 1)\n			--backs off when about to stop lunging\n			if (Tick - LastAttack > 0.5) then\n				--LungingGui.BackgroundColor3 = Color3.new(0.0470588, 1, 0) \n				\n				IdealDistance += 1.5 -- 2\n			end\n\n			\n			if Distance <= 8.5 then\n				Tool:Activate()\n				for _ = 1, 7 do\n					Model:SetPrimaryPartCFrame(Model.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(51.42857142857143), 0))\n					game:GetService(\'RunService\').RenderStepped:Wait()\n				end\n			elseif XDist < 13.5 then --15\n				Tool:Activate()\n			end\n\n\n			\n			if Distance > 8 then\n				if LowerHp then \n					IdealDistance += 1\n				end\n			end\n			\n			\n			--local SpacedPosition = ClosestEnemy.PrimaryPart.Position - (ClosestEnemy.PrimaryPart.Position - PrimaryPart.Position).Unit*IdealDistance\n			\n			local Offset = -ClosestEnemy.PrimaryPart.CFrame.RightVector\n			local SideCast = Funcs.SideCast(ClosestEnemy)\n			\n\n			if HigherHp and SameHeight then \n				Offset*= 3\n				IdealDistance = 1.5 -- 2\n			end\n			\n			if SideCast or Tool.Grip == Grips.Up then \n				Offset = Vector3.new(0,0,0)\n			end\n			\n			--using closestpos could be counterintuitive because it uses the root part's magnitude (so it's simpler to calculate range) but it gets applied to the closest part which might not work in all situations\n			--favoring the side without the sword\n			local SpacedPosition = (ClosestPos - (ClosestPos - PrimaryPart.Position).Unit*IdealDistance) + Offset\n			if HigherHp then \n				Offset*= 3\n				--SpacedPosition = ClosestEnemy[\'Left Arm\'].Position  + Offset\n			end\n		\n			\n			if Distance < IdealDistance then \n				local RetreatPos = Funcs.GetRetreatDirection(Model, ClosestEnemy,10)\n				if RetreatPos and EnemyIsMovingTowardsModel then \n					RetreatPos = Funcs.GetRetreatDirection(Model, ClosestEnemy,100)\n					Humanoid:MoveTo(RetreatPos)\n				else\n					Humanoid:MoveTo(SpacedPosition)\n				end\n			else \n				Humanoid:MoveTo(SpacedPosition)\n			end\n		else\n			task.wait()\n		end\n	end\nend"
Bot.Parent = game:GetService("ReplicatedStorage")

local Util = Instance.new("ModuleScript")
Util.Name = "Util"
Util.Source = "local Funcs = {}\n\nlocal function getPlayerCharacters()\n	local t = {}\n	for i,v in game.Players:GetChildren() do\n		if v.Character then\n			table.insert(t, v.Character)\n		end\n	end\n	return t\nend\nFuncs.VisualizePosition = function(Position)\n	local Part = Instance.new(\'Part\')\n	Part.Position = Position\n	Part.CanCollide = false\n	Part.Parent = workspace.Filter\n	Part.Size = Vector3.new(0.1,0.1,0.1)\n	Part.Anchored = true\nend\n\nFuncs.GetDist = function(Model, Position)\n	return (Model[\'Right Arm\'].Position - Position).Magnitude\nend\n\n\nFuncs.GetClosestEnemy = function(Model, teamCheck)\n	local ClosestEnemy = nil\n	local ClosestDistance = math.huge\n	for i, v in pairs(game.Players:GetChildren()) do \n		local character = v.Character\n		if character then\n			local humanoid = character:FindFirstChildWhichIsA(\'Humanoid\')\n			if humanoid and humanoid.Health > 0 then\n				if v.Name ~= Model.Name and (v.Team ~= game.Players[Model.Name].Team or not teamCheck) and v.Character.PrimaryPart then\n					local Dist = (v.Character.PrimaryPart.Position - Model.PrimaryPart.Position).Magnitude\n					if Dist < ClosestDistance and not v.Character:FindFirstChildOfClass(\'ForceField\') then\n						ClosestDistance = Dist\n						ClosestEnemy = v.Character\n					end\n				end\n			end\n		end\n	end\n	\n	\n	return ClosestEnemy\nend\n\nFuncs.GetDistance = function (Model, OtherModel)\n	return (Model.PrimaryPart.Position - OtherModel.PrimaryPart.Position).Magnitude\nend\n\nFuncs.GetClosestPart = function(Position, OtherModel)\n	local ClosestPart = nil\n	local ClosestDistance = math.huge\n	for i,v in pairs(OtherModel:GetChildren()) do \n		if v:IsA(\'BasePart\') then \n			local Offset = Vector3.new(0,0,0)\n			if v.Name == \'Right Arm\' then \n				\n				Offset = OtherModel.PrimaryPart.CFrame.LookVector*3\n			end\n			\n			local Dist = (Position - (v.Position+Offset)).Magnitude\n			if Dist < ClosestDistance then\n				ClosestDistance = Dist\n				ClosestPart = v\n			end\n		end\n	end\n	 \n	return ClosestPart\nend\n\nFuncs.GetRetreatDirection = function(Model, ClosestEnemy, Dist)\n	local Difference = (Model.PrimaryPart.Position - ClosestEnemy.PrimaryPart.Position)\n	local Params = RaycastParams.new()\n	Params.FilterType = Enum.RaycastFilterType.Blacklist\n	Params.FilterDescendantsInstances = getPlayerCharacters()\n	-- must be 10 for now otherwise it might run towards the player\n	-- maybe increase to 100 when the closest hit is <10? that way it knows when it's getting cornered\n	--local Dist = 10 \n	local Angle = -135\n	local BestDist = 0\n	local BestPosition = nil\n	local Raycasts = 10\n	for i = 1, Raycasts do\n		local Raycast = workspace:Raycast(Model.PrimaryPart.Position, (CFrame.lookAt(Model.PrimaryPart.Position, Model.PrimaryPart.Position + Difference)*CFrame.Angles(0,math.rad(Angle),0)).LookVector*Dist, Params)\n		\n		if Raycast then \n			local Dist = (Raycast.Position - ClosestEnemy.PrimaryPart.Position).Magnitude\n			if Dist > BestDist then \n				BestPosition = Raycast.Position\n				BestDist = Dist\n			end\n		end\n		\n		Angle += 270/Raycasts\n		\n	end\n	\n	return BestPosition\nend\n\nFuncs.SideCast = function(ClosestEnemy)\n	local Params = RaycastParams.new()\n	Params.FilterType = Enum.RaycastFilterType.Blacklist\n	Params.FilterDescendantsInstances = getPlayerCharacters()\n	local Angle = 0\n	local BestDist = 0\n	local BestPosition = nil\n	local Raycasts = 10\n	for i = 1,Raycasts do \n		local Raycast = workspace:Raycast(ClosestEnemy.PrimaryPart.Position, (ClosestEnemy.PrimaryPart.CFrame * CFrame.Angles(0,math.rad(Angle),0)).LookVector*8, Params)\n		Angle += 360/Raycasts\n		if Raycast then \n			return Raycast\n		end\n	end\n	\n\nend\n\nreturn Funcs"
Util.Parent = Bot

local FindBestAngle = Instance.new("ModuleScript")
FindBestAngle.Name = "FindBestAngle"
FindBestAngle.Source = "local VisualizePosition = function(Position)\n	local Part = Instance.new(\'Part\')\n	Part.Position = Position\n	Part.CanCollide = false\n	Part.Parent = workspace.Filter\n	Part.Size = Vector3.new(0.1,0.1,0.1)\n	Part.Anchored = true\nend\n\nlocal function GetDist(Model, Position)\n	return (Model[\'Right Arm\'].Position - Position).Magnitude\nend\n\nreturn function(Model, Enemy, EnemyTool)\n	\n	local Params = RaycastParams.new()\n	Params.FilterType = Enum.RaycastFilterType.Blacklist\n	Params.FilterDescendantsInstances = {Model, workspace.Filter, EnemyTool, table.unpack(Enemy.Humanoid:GetAccessories())}\n	\n	local Raycasts = {}\n	table.insert(Raycasts, {workspace:Raycast(Model[\'Right Arm\'].Position, Model.PrimaryPart.CFrame.LookVector*10, Params), 0})\n	table.insert(Raycasts, {workspace:Raycast(Model[\'Right Arm\'].Position, (Model.PrimaryPart.CFrame * CFrame.Angles(0,-math.rad(1),0)).LookVector.Unit*10, Params), -1})\n	table.insert(Raycasts, {workspace:Raycast(Model[\'Right Arm\'].Position, (Model.PrimaryPart.CFrame * CFrame.Angles(0,math.rad(1),0)).LookVector.Unit*10, Params), 1})\n	table.insert(Raycasts, {workspace:Raycast(Model[\'Right Arm\'].Position, (Model.PrimaryPart.CFrame * CFrame.Angles(0,math.rad(2),0)).LookVector.Unit*10, Params), 2})\n	table.insert(Raycasts, {workspace:Raycast(Model[\'Right Arm\'].Position, (Model.PrimaryPart.CFrame * CFrame.Angles(0,-math.rad(2),0)).LookVector.Unit*10, Params), -2})\n	workspace.Filter:ClearAllChildren()\n	local ClosestDistance = math.huge\n	local ClosestAngle = 0\n	local ClosestPos = nil\n	for i,v in pairs(Raycasts) do \n		if v[1] then\n			local Dist = GetDist(Model, v[1].Position)\n			\n			if Dist < ClosestDistance then\n				ClosestDistance = Dist\n				ClosestAngle = v[2]\n				ClosestPos = v.Position\n			end\n		end\n	end\n	\n	\n\n	return ClosestAngle\n	\nend"
FindBestAngle.Parent = Bot
